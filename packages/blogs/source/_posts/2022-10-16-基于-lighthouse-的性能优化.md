---
title: 基于 lighthouse 的性能优化
date: 2022-10-16 15:43:53
tags: [lighthouse, 性能优化]
categories: frontend
---

前端性能优化是一个老生常谈的话题了。要做性能优化，首先明确性能指的是什么。

## 指标

描述前端性能的指标已经经历了很多的变化了。一开始使用的是 `DOMContentLoaded` 和 `onload` 事件，前者指的是浏览器解析完毕初始 HTML 中所有的标签，后者指的是页面中所有的资源，包括图片字体等加载完毕。

后来有了 `navigation.timing` API，前端终于可以精确获取一个页面的整个生命周期过程中的所有关键时间节点，基于这些时间节点，我们可以根据自己的需要去自定义指标，进而衡量页面性能。

再后来，Google 推出了 web-vitals 这一套指标体系，用于衡量页面的性能，性能评分对搜索引擎的结果排名有着直接关系。Lighthouse 则是在 Chrome 里集成的，用于便携测量 web-vitals 性能评分的工具。

<!--more-->

web-vitals 的核心性能指标包括三个方面：

1. LCP。最大内容渲染时间，指的是从页面中最大的文字或者图片渲染完毕所需的时间，衡量的页面的渲染速度。
2. FID。首次输入延迟，指的是从用户触发某个事件到浏览器响应这个事件所需的时间，衡量的是页面的交互速度。
3. CLS。累计布局偏移，指的是页面上的内容位置发生突变的程度，衡量的是页面内容的稳定性。

## 测量

正所谓，想要优化，先要测量。只有拿到定量的数据之后，才能制定有针对性的优化方案。

性能指标的测量一般有两个方式：

1. 实验室测量。指的是在一些特定的条件下，我们用相应的工具自行测量收集数据。
2. 真实用户测量。指的是在页面中使用数据上报的方式，在真实的用户与页面进行交互的时候，收集性能数据。

实验室测量结果一般可以在开发阶段使用，在业务迭代的过程中，时刻关注代码的变动对性能产生了怎样的影响。而真实用户测量则可以用来建立监控和告警。

在 Lighthouse 中，没有办法直接测量 FID，所以使用了 TBT 和 TTI 来作为替代。

## 优化

有了实际的性能数据之后，就可以提出针对性的优化方案了。

概括的说，前端性能优化的核心就是优化**关键渲染路径**。所谓关键渲染路径，就是从用户开始导航，到页面渲染完毕可以进行交互的整个链路中不可或缺的部分。那么，要优化关键渲染路径，核心思路就是：

1. 去掉不属于关键渲染路径上的资源
2. 让关键渲染路径上的资源变小、变快

要做到这两点，我们可以从页面或者说是应用的整个生命周期出发。Web 应用的资源来自打包产物，打包产物会被放置到服务器上，用户请求相应的资源之后，浏览器下载解析执行渲染之后，页面最终呈现在用户眼前。

### 打包优化

我们首先考虑打包优化，一般包括以下几点：

1. 冗余代码。通过 Tree Shaking 的技术，消除冗余代码。
2. 重复代码。代码中存在的冗余代码，可以通过重构的方式消除。
3. 第三方库。一些第三方库体积巨大，需要使用按需导入的方式去引用。甚至于如果只是使用了第三方库的一小部分功能，可以自行参考实现。
4. 图片等静态资源。可以使用一些无损压缩的工具，对图片资源进行压缩。同时也可以采用新的更小的图片格式，比如 webp。

### 服务端优化

应用的渲染方式一般有客户端渲染，服务端渲染。

客户端渲染相对而言会有一个较长的白屏时间，页面内容需要在客户端脚本执行完毕之后才会得到渲染。对于一些有 SEO 需求的应用来说，客户端渲染不是一个合适的方式。

服务端渲染会在接收到用户请求的时候，在服务端动态生成 HTML 文件，这样浏览器就可以快速渲染出首屏页面。结合 headless 浏览器，我们甚至可以做到预渲染，在打包的时候就生成静态的 HTML，这样可以极大地降低服务端渲染的时间。

### 客户端优化

无论采用那种渲染方式，浏览器在拿到初始 HTML 之后，真正的页面渲染就开始了。在这个过程中，影响解析渲染的因素主要是后续的网络资源，包括 CSS，JS，字体，图片，视频等。

这些静态文件，并非全部都是首屏所需要的。通过使用相应的工具，都可以把非首屏资源从剥离出去，然后进行压缩之后再进行传输。

我们可以使用 Resource Hint 告知浏览器哪些资源是需要提前获取的，哪些资源的优先级较低，可以等到空闲时间再加载。

`preconnect` 和 `dis-prefetch` 可以提早告知浏览器需要与哪些资源服务器建立连接。`preload` 和 `prefetch` 则可以用来安排各种网络资源的优先级。对于后续渲染子路由所需的资源，或者是用户交互之后才会产生的 `Modal` 等，都可以通过延迟加载的方式来处理。

当然，还可以设置缓存加快资源加载效率。不过 Lighthouse 里进行测试评分的话，是会忽略缓存的。

JS 的执行过程与页面渲染是在同一个线程当中，因此，一旦有长任务存在，页面的可交互性就会变差，因此需要优化 JS 的执行。

我们可以使用 requestIdleCallback 去包裹长任务。如果存在比较复杂的计算逻辑，我们可以使用 web worker 去执行，通过 message 来与主线程通信。

对于图片和视频资源，很重要的一点是提前确定大小，并根据不同的大小，加载合适尺寸的资源。这样能够有效防止 layout shift。

### 特定框架的优化（React)

在 React 中，我们可以使用一些特定的 API 来跳过组件不必要的渲染，比如 `React.memo` 和 `shouldComponentUpdate`。还可以用 `useMemo` 来记忆计算结果。在创建组件时，尽可能避免组件层级过深，以提升 render 效率。

需要注意的一点是，React 提供的性能优化手段都只应该在真正需要的时候才能使用，因为优化是有代价的。如果盲目使用这些 API，可能牺牲了代码的简洁，却没有得到预期的效果。
